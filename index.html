<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>US Vaccination Map</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  
  <!-- Load MapLibre GL JS (the open-source fork of Mapbox GL JS v1) -->
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />

  <!-- Mapbox Geocoder alternative for MapLibre -->
  <script src="https://cdn.jsdelivr.net/npm/@maplibre/maplibre-gl-geocoder@1.7.0/dist/maplibre-gl-geocoder.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@maplibre/maplibre-gl-geocoder@1.7.0/dist/maplibre-gl-geocoder.css" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  

  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #search-toggle {
      position: absolute; top: 10px; left: 10px; z-index: 2;
      background: white; border-radius: 6px; padding: 5px 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      font-family: sans-serif;
    }

    .maplibregl-ctrl-top-right {z-index: 10; }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="search-toggle">
    <label><input type="radio" name="searchMode" value="county" checked> County</label>
    <label><input type="radio" name="searchMode" value="zip"> ZIP Code</label>
  </div>

  <script>
    //create the map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'osm-tiles': {
            type: 'raster',
            tiles: [
              'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
              'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
              //'https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
              //'https://d.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
            ],
            tileSize: 256,
            attribution:
              '© OpenStreetMap contributors © CARTO'
          }
        },
        layers: [
          {
            id: 'osm-tiles',
            type: 'raster',
            source: 'osm-tiles'
          }
        ]
      },
      center: [-98, 38.5],
      zoom: 4
    });

    //add zoom and rotation
    map.addControl(new maplibregl.NavigationControl(), 'top-right');

    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });

    let countyData;
    let zipData;
    
    //county layer
    map.on('load', async () => {
      const countyResponse = await fetch('counties.geojson');
      countyData = await countyResponse.json()
      countyData.features.forEach(f => {
        if (f.properties.mean_vaccination_rate_county == null)
          f.properties.mean_vaccination_rate_county = 0;
      });

      map.addSource('counties', {
        type: 'geojson',
        data: countyData 
    });

      map.addLayer({
        id: 'county-fill',
        type: 'fill',
        source: 'counties',
        maxzoom: 7,
        paint: {
          'fill-color': [
            'interpolate', ['linear'], ['get', 'mean_vaccination_rate_county'],
            0, '#89cff1',
            40, '#6eb1d6',
            50, '#5293bb',
            60, '#3776a1',
            70, '#1b5886',
            80, '#1b2d86',
            90, '#06124d'
          ],
          'fill-opacity': 0.7
        }
      });

      map.addLayer({
        id: 'county-outline',
        type: 'line',
        source: 'counties',
        maxzoom: 10,
        paint: { 'line-color': '#555', 'line-width': 0.5 }
      });

      const zipResponse = await fetch('zipcodes.geojson');
      zipData = await zipResponse.json()
      
      map.addSource('zipcodes', { type: 'geojson', data: zipData });

      map.addLayer({
        id: 'zip-fill',
        type: 'fill',
        source: 'zipcodes',
        minzoom: 7,
        paint: {
          'fill-color': [
            'match', ['get', 'risk_level_zcta'],
            'Lowest Risk (85%+)', '#89cff1',
            'Low Risk (80–84%)', '#6eb1d6',
            'Medium Risk (70–79%)', '#5293bb',
            'High Risk (60–69%)', '#1b2d86',
            'Very High Risk (<60%)', '#06124d',
            '#cccccc'
          ],
          'fill-opacity': 0.7
        }
      });

      map.addLayer({
        id: 'zip-outline',
        type: 'line',
        source: 'zipcodes',
        minzoom: 7,
        paint: { 'line-color': '#444', 'line-width': 0.3 }
      });
      

      // Hover tooltip
      map.on('mousemove', 'county-fill', e => {
        map.getCanvas().style.cursor = 'pointer';
        const f = e.features[0];
        popup.setLngLat(e.lngLat)
          .setHTML(`<h1>${f.properties.county_state}</h1><br><b>Mean Vaccination Rate:</b> ${f.properties.mean_vaccination_rate_county}%<br><b>Risk Level:</b> ${f.properties.risk_level_county}<br><b>Statewide Measles Cases in 2025:</b> ${f.properties.cases}`)
          .addTo(map);
      });
      map.on('mouseleave', 'county-fill', () => popup.remove()); //map.getCanvas().style.cursor = ''; });

    
      

      // Tooltip for ZIPs
      map.on('mousemove', 'zip-fill', e => {
        const f = e.features[0];
        popup.setLngLat(e.lngLat)
          .setHTML(`<h1>ZIP ${f.properties.zcta5}</h1><br><b>Zip Code Risk Level:</b> ${f.properties.risk_level_zcta}<br><b>County Risk Level:</b> ${f.properties.risk_level_county}<br><b>State Measles Cases in 2025</b>: ${f.properties.cases} `)
          .addTo(map);
      });
      map.on('mouseleave', 'zip-fill', () => popup.remove()); //map.getCanvas().style.cursor = ''})

      // Free Geocoder
      const geocoder = new MaplibreGeocoder({
        placeholder: 'Search by county or ZIP code...',
        flyTo: false,
        zoom: null,
        collapsed: false,
        forwardGeocode: async (query) => {
          try {
            const results = [];
            const mode = document.querySelector('input[name="searchMode"]:checked').value;
            //Normalize query 
            const q = (
              typeof query === 'string'
                ? query
                : query && query.query
                  ? query.query
                  : ''
            ).trim().toLowerCase();

            if (!q) return { features: []}; //avoid undefined errors

            if (mode === 'county') {
              const res = await fetch('counties.geojson');
              const data = await res.json();
              data.features.forEach(f => {
                const name = (f.properties.county_state || '').toLowerCase();
                if (name.includes(q)) {
                  if (f.properties.mean_vaccination_rate_county == null)
                    f.properties.mean_vaccination_rate_county = 0;
                  let center = [-98,38.5];
                  if (f.geometry && f.geometry.coordinates && f.geometry.coordinates.length) {
                    try {
                      center = turf.center(f).geometry.coordinates;
                    } catch (err) {
                      console.warn('turf.center failed for', f.properties.county_state, err);
                    }
                  }

                  //const center = turf.center(f).geometry.coordinates;
                results.push({
                  type: 'Feature',
                  geometry: {
                    type: 'Point',
                    coordinates: center
                  },
                  place_name: `${f.properties.county_state}`,
                  text: `${f.properties.county_state}`,
                  center,
                  properties: f.properties
                  });
                }
              });
            } else if (mode === 'zip') {
              const res = await fetch('zipcodes.geojson');
              const data = await res.json();
              data.features.forEach(f => {
                const zip = String(f.properties.zcta5 || '');
                if (zip.startsWith(q)) {
                  let center = [-98, 38.5];
                  if (f.geometry && f.geometry.coordinates && f.geometry.coordinates.length) {
                    try {
                      center = turf.center(f).geometry.coordinates;
                    } catch (err) {
                      console.warn('turf.center failed for ZIP', zip, err)
                    }
                  }
                  results.push({
                    type: 'Feature',
                    geometry: {
                      type: 'Point',
                      coordinates: center
                    },
                    place_name: `ZIP ${f.properties.zcta5 || 'Unknown'}`,
                    text: `ZIP ${f.properties.zcta5}`,
                    center,
                    properties: f.properties
                  });
                }
              });
            }
          
            console.log("Offline geocoder results:", results.length);

            const safeResults = results.map(f => ({
              ...f,
              geometry: {
                type: 'Point',
                coordinates: f.center
              }
            }));

            return { features: safeResults };

          } catch (err) {
            console.error("Error in forwardGeocode:", err);
            //Always return an empty set on failure
            return {features: [] };
          }
        }
      },
        { maplibregl: maplibregl }
      );
      map.addControl(geocoder, 'top-right');

      // Optional safety override (stops internal flyTo even on Enter)
      geocoder.on('loading', () => {
        geocoder._map = null;
      });

      const geocoderInput = document.querySelector('.maplibregl-ctrl-geocoder input');

      geocoderInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const list = document.querySelector('.suggestions');
          const first = list?.querySelector('.suggestion');
          if (first) {
            first.click(); // simulate click
            e.preventDefault();
          }
        }
      });


      // Optional: listen for result events (forces zoom + highlight)
      geocoder.on('result', async (e) => {
        const feature = e.result;
        if (!feature || !feature.center) return;

        const isZip = !!feature.properties.zcta5;
        const zoomLevel = isZip ? 12 : 10;

        map.flyTo({
          center: feature.center,
          zoom: zoomLevel,
          essential: true
          });
        
        map.once('moveend', () => console.log('Zoom level:', map.getZoom()))
          // highlight effect

        let highlightFeature = null;

        if(isZip) {
          highlightFeature = zipData.features.find(
            f => String(f.properties.zcta5) === String(feature.properties.zcta5)
          );
        } else {
          highlightFeature = countyData.features.find(
            f => (f.properties.county_state || '').trim().toLowerCase() === (feature.properties. county_state || '').trim().toLowerCase()
          );
        }
        
        if(!highlightFeature) {
          console.warn('No polygon found for highlight.');
          return;
        }
      
        const highlightData = {
          type: 'FeatureCollection',
          features: [highlightFeature]
        };

        if (map.getSource('search-highlight')) {
          map.getSource('search-highlight').setData(highlightData);
        } else {
          map.addSource('search-highlight', { type: 'geojson', data: highlightData })
        }

        if (!map.getLayer('search-highlight-line')) {
          map.addLayer({
            id: 'search-highlight-line',
            type: 'line',
            source: 'search-highlight',
            paint: { 'line-color': '#ff6600', 'line-width': 3 }
          });
        }

        if (feature.properties && feature.properties.county_state && !isZip) {
          const selectedCounty = feature.properties.county_state;
          console.log('Filtering ZIP codes for:', selectedCounty)
        // Always reset ZIP source before re-filtering
          const zipResponse = await fetch('zipcodes.geojson');
          const allZipData = await zipResponse.json();
        //const countyRes = await fetch('counties.geojson');
        //const countyData = await countyRes.json();
          const countyFeature = countyData.features.find(f =>
            (f.properties.county_state || '').trim().toLowerCase() ===
            (selectedCounty || '').trim().toLowerCase()
          );

          if (!countyFeature || !countyFeature.geometry) {
            console.warn('No county match found for:', selectedCounty);
            return;
          }

          let countyGeoms = [];

          if (countyFeature.geometry.type === "Polygon") {
            countyGeoms = [countyFeature.geometry]; // already valid GeoJSON Polygon
          } else if (countyFeature.geometry.type === "MultiPolygon") {
           // Flatten to individual Polygon geometries
            const flat = turf.flatten(countyFeature);
            countyGeoms = flat.features.map(f => f.geometry);
          } else {
            console.warn("Unexpected county geometry type:", countyFeature.geometry.type);
            return; // bail out if invalid
          }

          const countyBbox = turf.bbox(countyFeature);

          console.log('County geometry type:', countyFeature.geometry.type);
          console.log('First county polygon sample:', JSON.stringify(countyGeoms[0].coordinates[0].slice(0, 3)));
          console.log('ZIP feature count before filtering:', zipData.features.length);

//Now safely filter ZIPs
          const filteredZips = zipData.features
          .map(z => ({
            ...z,
            properties: { ...z.properties }
          }))
          .filter(zip => {
            try {
              const centroid = turf.center(zip);
              const zipBbox = turf.bbox(zip);
              if (!turf.booleanDisjoint(turf.bboxPolygon(countyBbox), turf.bboxPolygon(zipBbox))) {
                if (countyGeoms.some(g => turf.booleanPointInPolygon(centroid, g))) {
                  return true;
                }
                return countyGeoms.some(g => turf.booleanIntersects(zip, g));
              }
              return false;
            } catch (err) {
              console.warn("turf test failed for ZIP", zip.properties.zcta5, err);
              return false;
            }
          });

          const categoryCount = filteredZips.reduce((acc, f) => {
            const cat = f.properties.risk_level_zcta || 'Unknown';
            acc[cat] = (acc[cat] || 0) + 1;
            return acc;
          }, {});
          console.log('ZIP category counts in selected county:', categoryCount);

          console.log('Filtered ZIPs sample:', filteredZips.slice(0, 5).map(z => z.properties.zcta5));
          console.log(`Found ${filteredZips.length} ZIP codes in ${selectedCounty}`)

          map.getSource('zipcodes').setData({
            type: 'FeatureCollection',
            features: filteredZips
          });
          map.triggerRepaint()
        }
        });

      //map.on('zoomend', async() => {
        //if (map.getZoom() <6 && map.getSource('zipcodes')) {
          //const zipRes = await fetch('zipcodes.geojson');
          //const zipData = await zipRes.json();
          //map.getSource('zipcodes').setData(zipData);
          //console.log('Restored all ZIP codes after zooming out');
        //}
      //});


      // Toggle for search placeholder
      document.querySelectorAll('input[name="searchMode"]').forEach(radio => {
        radio.addEventListener('change', e => {
          const mode = e.target.value;
          const input = document.querySelector('.maplibregl-ctrl-geocoder input');
          if (input) {
            input.placeholder = mode === 'county'
            ? 'Search by county...'
            : 'Search by ZIP code...';
          }
        });
      });
    });
  </script>
</body>
</html>
